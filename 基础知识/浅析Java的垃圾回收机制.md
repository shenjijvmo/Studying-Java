> 传统的C/C++等编程语言，需要程序员负责回收已经分配了的内存。但是显式进行垃圾回收是一件比较困难的事情，因为程序员并不总是清楚内存应该在什么时候释放。如果分配的内存不及时释放，会导致系统运行速度下降，甚至程序瘫痪，这种情况被称为内存泄漏。

总的来说，显式进行垃圾回收有两个**缺点**：
1. 程序忘记及时回收无用内存，导致内存泄漏，降低系统性能。
2. 程序错误的回收程序核心类库的内存，导致系统崩溃。

与C/C++不同，Java语言不需要程序员直接控制内存回收，Java程序的内存分配和回收都是由JRE在后台自动进行。JRE会负责回收那些不再使用的内存，这种机制被称为垃圾回收（GC）。通常JRE会提供一个后台线程来进行检测和控制，一般都是在CPU空闲或是内存不足时自动进行GC，而程序员无法精准控制垃圾回收的时间和顺序。

Java的堆内存是一个运行时数据区，用以保存类的实例。堆内存的回收由垃圾回收来负责，所有的JVM实现都有一个由垃圾回收器管理的堆内存。GC是一种动态存储管理技术，它自动释放不再被程序引用的对象，按照特定的垃圾回收算法来实现内存资源的自动回收功能。

在C/C++中，没有被释放的的对象所占用的内存将不能被分配给其他对象，该内存在程序结束运行之前都会被一直占用。

在Java中，当没有引用变量指向原先分配给某个对象的内存时，该内存成为垃圾。JVM的一个守护线程会自动释放该内存区。

除了释放没用的对象之外，垃圾回收也可以清除内存记录碎片。由于创建对象和垃圾回收器释放丢弃对象所占用的内存空间，内存会出现碎片。碎片整理就是将所占用的堆内存移到堆的一段，JVM将整理出的内存分配给新的对象。

GC能够自动释放内存空间，减轻编程负担。这使得Java虚拟机有两个显著**优点**：

1. 垃圾回收机制可以很好的提高编程效率。

2. 垃圾回收机制可以保证程序的完整性，也是Java语言安全性策略的一个重要部分。

以前Java的垃圾回收机制总是被C/C++程序员嘲笑，内存这么重要的东西，怎么可以交给GC处理，应该被程序员牢牢掌控在手中才对。确实，早年Java的垃圾回收机制不仅会影响程序的性能，还不能保证百分百收集到所有废弃的内存。但是随着Java新一代的垃圾回收机制G1登场以及软硬件运行效率的不断提升，Java的垃圾回收机制变得越来越可靠且高效。

最后要注意，GC具有如下**特点**：

1. 只能回收无用对象的内存空间，无法回收其他物理资源，如数据库连接、磁盘I/O等

2. 为了更快让垃圾回收机制回收不使用的对象，可以将对象的引用变量设置为null，暗示垃圾回收机制回收该对象占有的空间。

3. 垃圾回收发生的不可预知性。程序员无法控制垃圾回收，及时能够调用Runtime对象的gc()或System.gc()等方法建议系统进行GC，但这也仅仅是建议，并不能精准控制垃圾回收机制的执行。

4. 现有的JVM有多种不同的垃圾回收实现，每种回收机制因为算法的差异可能表现各异。