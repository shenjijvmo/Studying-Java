> 多线程编程是非常有用的，但是当使用多线程访问并修改可变资源时，如果不加控制，结果将变得难以预测

造成这个问题的原因可能是因为系统线程调度的随机性，也可能是编程不当。为了确保不读取到“脏数据”，我们有必要采用一定的手段，做到线程同步。

在Java中，我们大致有以下三种方法来做到线程同步：

1. 同步代码块
2. 同步方法
3. 同步锁

## 同步代码块
当有两个线程并发访问并修改同一个文件时，如果不进行线程同步，就容易造成异常。我们可以引入同步监视器来解决这个问题，使用同步监视器的通用方法就是使用同步代码块。同步代码块的语法格式如下：

```java
    synchronized (obj){
        //此处的代码为同步代码块
    }
```

上面的语法格式中，括号中的obj就是同步监视器。

这段代码的含义是：线程开始执行同步代码块之前，必须先获得对同步监视器的锁定。

**任何时刻都只能有一个线程可以获得对同步监视器的锁定，当同步代码块执行完成之后该线程会释放对该同步监视器的锁定。**

虽然Java程序允许使用任何对象作为同步监视器，但是通常推荐使用可能被并发访问的共享资源充当同步监视器，因为这样可以阻止多个线程对同一个共享资源进行并发访问。

## 同步方法

与同步代码块对应的，Java的多线程安全支持还提供了同步方法，同步方法就是使用synchronized关键词来修饰某个方法，则该方法被称为同步方法。

对于被synchronized修饰的实例方法，无需显式指定同步监视器，同步方法的监视器就是调用该方法的对象。

通过使用同步方法就可以非常方便的实现线程安全的类，线程安全的类具有以下特征：

1. 该类的对象可以被多个线程安全访问
2. 每个线程调用该对象的任意方法之后都可以得到正确结果
3. 每个线程调用该对象的任意方法之后，该对象状态仍然保持合理状态

需要注意的是：**synchronized关键字可以修饰方法，可以修饰代码块，但不能修饰构造器、成员变量。**

可变类的线程安全是以降低程序的运行效率为代价的，为了减少线程安全带来的负面效果，我们可以采用如下策略：

* 仅仅对会改变竞争资源的方法进行同步。
* 如果可变类有单线程环境和多线程环境两种不同的运行环境。则应该为该可变类提供两种不同的版本，即线程安全版本和线程不安全版本。例如StringBuilder和StringBuffer就是为了照顾单线程环境和多线程环境所提供的类。

## 同步锁
从Java5开始，Java提供了一种功能更加强大的线程同步机制，即通过显示地定义同步锁对象来实现通过不，在这种机制下，同步锁由Lock对象充当。

在实现线程安全的控制中，比较常用的是可重入锁（ReentrantLock），考虑下面这个示例：

```java
class LockTest{
    //获取可重入锁对象
    private final ReentrantLock lock = new ReentrantLock();
    
    public void test(){
        lock.lock();
        try{
            //需要保证线程安全的代码
        }finally {
            lock.unlock();
        }
    }
}
```


虽然采用同步方法和同步代码块的范围机制使得多线程编程非常方便，而且还可以避免很多设计锁的常见编程错误，但是有时也需要以更为灵活的方式来使用锁。

Lock提供了同步方法和同步代码块所没有的其他功能，比如用于非块结构的tryLcok()方法、试图获取可中断锁的lockInterruptibly()方法以及获取超时失效锁的tryLock(long,TimeUnit)方法。